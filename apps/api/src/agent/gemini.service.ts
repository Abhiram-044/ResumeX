import { Injectable, Logger } from '@nestjs/common';
import { GoogleGenAI } from '@google/genai';
import { ConfigService } from '@nestjs/config';
import { QuotasRepository } from 'src/repository/quotas.repository';

@Injectable()
export class GeminiService {
  private ai: GoogleGenAI;
  private readonly GEMINI_2DOT0_FLASH_RPM: number;
  private readonly GEMINI_2DOT0_FLASH_RPD: number;
  private readonly GEMINI_2DOT0_FLASH_TPM: number;

  private readonly GEMINI_2DOT0_FLASH_LITE_RPM: number;
  private readonly GEMINI_2DOT0_FLASH_LITE_RPD: number;
  private readonly GEMINI_2DOT0_FLASH_LITE_TPM: number;

  private readonly GEMINI_2DOT5_FLASH_PREVIEW_04_17_RPM: number;
  private readonly GEMINI_2DOT5_FLASH_PREVIEW_04_17_RPD: number;
  private readonly GEMINI_2DOT5_FLASH_PREVIEW_04_17_TPM: number;

  private readonly logger = new Logger(GeminiService.name);

  /**
   * Initializes the GeminiService.
   *
   * Retrieves the Gemini API key from the environment configuration and
   * uses it to initialize the GoogleGenAI client.
   *
   * Retrieves the rate limit configurations for the Gemini 2.0 Flash,
   * Gemini 2.0 Flash Lite, and Gemini 2.5 Flash Preview 04-17 models
   * from the environment configuration.
   *
   * Logs an error message if the Gemini API key is not configured
   * or if any of the rate limit configurations are not set.
   *
   * Logs a success message if all configurations are set.
   */
  constructor(
    private configService: ConfigService,
    private quotasRepository: QuotasRepository,
  ) {
    const apiKey = this.configService.get<string>('GEMINI_API_KEY');
    if (!apiKey) {
      this.logger.error('GEMINI_API_KEY is not configured');
    }
    this.ai = new GoogleGenAI({
      apiKey,
    });

    this.GEMINI_2DOT0_FLASH_RPM = this.configService.get<number>(
      'GEMINI_2DOT0_FLASH_RPM',
    );
    this.GEMINI_2DOT0_FLASH_RPD = this.configService.get<number>(
      'GEMINI_2DOT0_FLASH_RPD',
    );
    this.GEMINI_2DOT0_FLASH_TPM = this.configService.get<number>(
      'GEMINI_2DOT0_FLASH_TPM',
    );

    this.GEMINI_2DOT0_FLASH_LITE_RPM = this.configService.get<number>(
      'GEMINI_2DOT0_FLASH_LITE_RPM',
    );
    this.GEMINI_2DOT0_FLASH_LITE_RPD = this.configService.get<number>(
      'GEMINI_2DOT0_FLASH_LITE_RPD',
    );
    this.GEMINI_2DOT0_FLASH_LITE_TPM = this.configService.get<number>(
      'GEMINI_2DOT0_FLASH_LITE_TPM',
    );

    this.GEMINI_2DOT5_FLASH_PREVIEW_04_17_RPM = this.configService.get<number>(
      'GEMINI_2DOT5_FLASH_PREVIEW_04_17_RPM',
    );
    this.GEMINI_2DOT5_FLASH_PREVIEW_04_17_RPD = this.configService.get<number>(
      'GEMINI_2DOT5_FLASH_PREVIEW_04_17_RPD',
    );
    this.GEMINI_2DOT5_FLASH_PREVIEW_04_17_TPM = this.configService.get<number>(
      'GEMINI_2DOT5_FLASH_PREVIEW_04_17_TPM',
    );

    if (
      !this.GEMINI_2DOT0_FLASH_RPM ||
      !this.GEMINI_2DOT0_FLASH_RPD ||
      !this.GEMINI_2DOT0_FLASH_TPM ||
      !this.GEMINI_2DOT0_FLASH_LITE_RPM ||
      !this.GEMINI_2DOT0_FLASH_LITE_RPD ||
      !this.GEMINI_2DOT0_FLASH_LITE_TPM ||
      !this.GEMINI_2DOT5_FLASH_PREVIEW_04_17_RPM ||
      !this.GEMINI_2DOT5_FLASH_PREVIEW_04_17_RPD ||
      !this.GEMINI_2DOT5_FLASH_PREVIEW_04_17_TPM
    ) {
      this.logger.error('Gemini Rate Limit Configurations are not set');
    }

    this.logger.log('Gemini Rate Limit Configurations are set');
  }

  /**
   * Generates content using the specified AI model.
   *
   * @param model - The AI model to be used for content generation.
   * @param config - Configuration settings for the model.
   * @param contents - An array of content objects, each containing parts with text or inlineData.
   *
   * @throws {Error} Throws an error if the contents structure is invalid or if each part lacks text or inlineData.
   * @throws {Error} Throws an error if the rate limit is exceeded.
   * @throws {Error} Throws an error if the response from the Gemini API is empty or invalid.
   * @throws {Error} Throws an error if no content parts are found in the Gemini response.
   *
   * @returns {string} Returns the text content generated by the AI model.
   */
  async generateContent(model, config, contents) {
    try {
      if (
        !contents ||
        !contents.length ||
        !contents[0].parts ||
        !contents[0].parts.length
      ) {
        throw new Error('Invalid contents structure provided');
      }

      contents.forEach((content) => {
        content.parts.forEach((part) => {
          if (!part.text && !part.inlineData) {
            throw new Error('Each part must have either text or inlineData');
          }
        });
      });

      const isRateLimitExceeded = await this.checkRateLimit(model);

      if (!isRateLimitExceeded) {
        throw new Error('Rate Limit Exceeded');
      }

      const response = await this.ai.models.generateContent({
        model,
        config,
        contents,
      });

      if (!response || !response.candidates || !response.candidates.length) {
        throw new Error('Empty or invalid response from Gemini API');
      }

      const candidateContent = response.candidates[0].content;
      if (
        !candidateContent ||
        !candidateContent.parts ||
        !candidateContent.parts.length
      ) {
        throw new Error('No content parts found in Gemini response');
      }

      this.manageRateLimit(model, response.usageMetadata.totalTokenCount);

      const textContent = candidateContent.parts[0].text;

      return textContent;
    } catch (error) {
      this.logger.error('Error while making Gemini Service Call', error);
      throw error;
    }
  }

  /**
   * Manages the rate limits for the specified model.
   *
   * This function updates the global quota usage for the given model by incrementing
   * the count for requests per minute (RPM) and requests per day (RPD) by 1, and
   * adding the specified usage to tokens per minute (TPM) and tokens per day (TPD).
   *
   * @param model - The model identifier for which the rate limits are being managed.
   * @param usage - The number of tokens used, which will be added to the TPM and TPD quotas.
   */
  private manageRateLimit(model: string, usage: number) {
    this.quotasRepository.setGlobalQuotaUsage(model, 1, 'rpm');
    this.quotasRepository.setGlobalQuotaUsage(model, Number(usage), 'tpm');
    this.quotasRepository.setGlobalQuotaUsage(model, 1, 'rpd');
    this.quotasRepository.setGlobalQuotaUsage(model, Number(usage), 'tpd');
  }

  /**
   * Checks if the rate limits for the given model are exceeded.
   *
   * This function retrieves the current rate usage for the specified model and compares it
   * against the predefined rate limits for requests per minute (RPM), tokens per minute (TPM),
   * and requests per day (RPD). If any of these limits are exceeded, it logs an error and
   * returns false. If the limits are not exceeded, it logs a debug message and returns true.
   *
   * @param model - The model identifier to check rate limits for (e.g., 'gemini-2.0-flash').
   * @returns A promise resolving to true if the rate limits are not exceeded, otherwise false.
   */
  async checkRateLimit(model: string) {
    const rpm: number =
      (await this.quotasRepository.getGlobalQuotaUsage(model, 'rpm')) || 0;
    const tpm: number =
      (await this.quotasRepository.getGlobalQuotaUsage(model, 'tpm')) || 0;
    const rpd: number =
      (await this.quotasRepository.getGlobalQuotaUsage(model, 'rpd')) || 0;

    let currentModel: string;

    if (model === 'gemini-2.0-flash') {
      currentModel = 'GEMINI_2DOT0_FLASH';
    } else if (model === 'gemini-2.0-flash-lite') {
      currentModel = 'GEMINI_2DOT0_FLASH_LITE';
    } else if (model === 'gemini-2.5-flash-preview-04-17') {
      currentModel = 'GEMINI_2DOT5_FLASH_PREVIEW_04_17';
    }

    if (!currentModel) {
      this.logger.error('Invalid Model', model);
      return false;
    }

    if (Number(rpd) >= Number(this[currentModel + '_RPD'])) {
      // this.logger.error(
      //   'Rate Limit Per Day Exceeded',
      //   model,
      //   'Current RPD: ',
      //   rpd,
      //   'Limit RPD: ',
      //   this[currentModel + '_RPD'],
      // );
      return false;
    }

    if (Number(tpm) >= Number(this[currentModel + '_TPM'])) {
      // this.logger.error(
      //   'Token Limit Per Minute Exceeded',
      //   model,
      //   'Current TPM: ',
      //   tpm,
      //   'Limit TPM: ',
      //   this[currentModel + '_TPM'],
      // );
      return false;
    }

    if (Number(rpm) >= Number(this[currentModel + '_RPM'])) {
      // this.logger.error(
      //   'Rate Limit Per Minute Exceeded',
      //   model,
      //   'Current RPM: ',
      //   rpm,
      //   'Limit RPM: ',
      //   this[currentModel + '_RPM'],
      // );
      return false;
    }

    // this.logger.debug('Rate Limit Check Passed', model);
    return true;
  }
}
